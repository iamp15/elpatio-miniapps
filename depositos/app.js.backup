// Configuraci√≥n de la Mini App
// Actualizado: 2024-01-24 - Integraci√≥n con Railway backend
class DepositApp {
  constructor() {
    this.tg = window.Telegram.WebApp;
    this.currentTransaction = null;
    this.userData = null;
    // Configuraci√≥n del backend basada en el ambiente
    this.backendUrl = this.getBackendUrl();
    // Estado de logs visuales (inicialmente ocultos)
    this.logsVisibles = false;

    this.init();
  }

  // Obtener URL del backend basada en el ambiente
  getBackendUrl() {
    // En desarrollo local
    if (
      window.location.hostname === "localhost" ||
      window.location.hostname === "127.0.0.1"
    ) {
      return "http://localhost:3001/api";
    }

    // En Vercel (desarrollo), usar Railway backend
    if (window.location.hostname.includes("vercel.app")) {
      // URL del backend en Railway (actualizar con tu URL real)
      return "https://elpatio-backend-production.up.railway.app/api";
    }

    // En producci√≥n real
    return "https://elpatio-backend-production.up.railway.app/api";
  }

  // Inicializaci√≥n de la app
  init() {
    console.log("üöÄ Inicializando Mini App de Dep√≥sitos");

    // Configurar Telegram Web App
    this.tg.ready();
    this.tg.expand();

    // Crear bot√≥n toggle de logs
    this.crearBotonToggleLogs();

    // Obtener datos del usuario
    this.userData = this.tg.initDataUnsafe?.user;

    if (!this.userData) {
      this.showError(
        "Error de autenticaci√≥n",
        "No se pudieron obtener los datos del usuario"
      );
      return;
    }

    console.log("üë§ Usuario:", this.userData);

    // Configurar tema
    this.setupTheme();

    // Configurar eventos
    this.setupEventListeners();

    // Configurar eventos de confirmaci√≥n de pago
    this.setupPaymentConfirmationEvents();

    // Cargar saldo inicial
    this.loadUserBalance();

    // Mostrar pantalla principal
    this.showScreen("main-screen");
  }

  // Configurar tema de Telegram
  setupTheme() {
    const theme = this.tg.colorScheme;
    console.log("üé® Tema:", theme);

    // Aplicar colores del tema
    document.documentElement.style.setProperty(
      "--tg-theme-bg-color",
      this.tg.themeParams.bg_color || "#ffffff"
    );
    document.documentElement.style.setProperty(
      "--tg-theme-text-color",
      this.tg.themeParams.text_color || "#000000"
    );
    document.documentElement.style.setProperty(
      "--tg-theme-hint-color",
      this.tg.themeParams.hint_color || "#999999"
    );
    document.documentElement.style.setProperty(
      "--tg-theme-link-color",
      this.tg.themeParams.link_color || "#2481cc"
    );
    document.documentElement.style.setProperty(
      "--tg-theme-button-color",
      this.tg.themeParams.button_color || "#2481cc"
    );
    document.documentElement.style.setProperty(
      "--tg-theme-button-text-color",
      this.tg.themeParams.button_text_color || "#ffffff"
    );
    document.documentElement.style.setProperty(
      "--tg-theme-secondary-bg-color",
      this.tg.themeParams.secondary_bg_color || "#f1f1f1"
    );
  }

  // Configurar event listeners
  setupEventListeners() {
    // Formulario de solicitud de dep√≥sito
    document.getElementById("deposit-form").addEventListener("submit", (e) => {
      e.preventDefault();
      this.handleDepositRequest();
    });

    // C√°lculo autom√°tico de centavos
    document.getElementById("amount").addEventListener("input", (e) => {
      this.calculateCents(e.target.value);
    });

    // Bot√≥n "Ya realic√© el pago"
    document
      .getElementById("payment-done-btn")
      .addEventListener("click", () => {
        this.showScreen("payment-confirmation-screen");
      });

    // Formulario de confirmaci√≥n de pago
    document
      .getElementById("payment-confirmation-form")
      .addEventListener("submit", (e) => {
        e.preventDefault();
        this.handlePaymentConfirmation();
      });

    // Bot√≥n volver
    document
      .getElementById("back-to-bank-btn")
      .addEventListener("click", () => {
        this.showScreen("bank-info-screen");
      });

    // Bot√≥n cerrar app
    document.getElementById("close-app-btn").addEventListener("click", () => {
      this.tg.close();
    });

    // Botones de error
    document.getElementById("retry-btn").addEventListener("click", () => {
      this.showScreen("main-screen");
    });

    document.getElementById("close-error-btn").addEventListener("click", () => {
      this.tg.close();
    });

    // Configurar fecha actual por defecto
    document.getElementById("payment-date").value = new Date()
      .toISOString()
      .split("T")[0];
  }

  // Configurar eventos de confirmaci√≥n de pago
  setupPaymentConfirmationEvents() {
    // El bot√≥n "Ya realic√© el pago" ya est√° configurado en setupEventListeners
    // Aqu√≠ podemos agregar configuraciones adicionales si es necesario
    console.log("‚úÖ Eventos de confirmaci√≥n de pago configurados");
  }

  // Mostrar pantalla espec√≠fica
  showScreen(screenId) {
    // Ocultar todas las pantallas
    document.querySelectorAll(".screen").forEach((screen) => {
      screen.classList.remove("active");
    });

    // Mostrar pantalla seleccionada
    const screen = document.getElementById(screenId);
    if (screen) {
      screen.classList.add("active");
      console.log(`üì± Mostrando pantalla: ${screenId}`);
    }
  }

  // Cargar saldo del usuario
  async loadUserBalance() {
    try {
      // Mostrar estado de carga
      document.getElementById("current-balance").textContent = "Cargando...";

      // Obtener saldo real del backend
      const balance = await this.getUserBalance();

      // Formatear saldo con separadores de miles
      const formattedBalance = this.formatCurrency(balance);
      document.getElementById(
        "current-balance"
      ).textContent = `${formattedBalance} Bs`;

      console.log("‚úÖ Saldo cargado exitosamente:", formattedBalance, "Bs");
    } catch (error) {
      console.error("‚ùå Error cargando saldo:", error);

      // Mostrar mensaje de error m√°s espec√≠fico
      let errorMessage = "No disponible temporalmente";

      if (error.message.includes("404")) {
        errorMessage = "Usuario no encontrado";
      } else if (error.message.includes("Backend no disponible")) {
        errorMessage = "Backend no disponible";
      } else if (error.message.includes("fetch")) {
        errorMessage = "Error de conexi√≥n";
      }

      document.getElementById("current-balance").textContent = errorMessage;

      // Mostrar mensaje de error en la consola para debugging
      console.warn("‚ö†Ô∏è No se pudo cargar el saldo:", error.message);
    }
  }

  // Obtener saldo del usuario desde el backend
  async getUserBalance() {
    try {
      console.log("üîç Iniciando obtenci√≥n de saldo...");
      console.log("üîó Backend URL:", this.backendUrl);
      console.log("üë§ Usuario ID:", this.userData?.id);

      // Si no hay backend disponible, lanzar error
      if (!this.backendUrl) {
        console.error("‚ùå Backend no disponible");
        throw new Error("Backend no disponible");
      }

      // Obtener el ID del jugador desde los datos de Telegram
      const telegramId = this.userData.id.toString();
      const fullUrl = `${this.backendUrl}/webapp/jugadores/${telegramId}/saldo`;

      console.log("üì° Haciendo petici√≥n a:", fullUrl);

      // Hacer llamada al endpoint del backend con autenticaci√≥n de Telegram
      const response = await fetch(fullUrl, {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
          "X-Telegram-ID": telegramId,
        },
      });

      console.log(
        "üìä Respuesta recibida:",
        response.status,
        response.statusText
      );

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(
          errorData.message ||
            `Error del servidor: ${response.status} - ${response.statusText}`
        );
      }

      const data = await response.json();
      console.log("üìä Datos recibidos:", data);

      if (data.success && data.saldo !== undefined) {
        // Convertir centavos a bol√≠vares
        const balanceInBs = data.saldo / 100;
        console.log(
          "‚úÖ Saldo obtenido:",
          data.saldo,
          "centavos =",
          balanceInBs,
          "Bs"
        );
        return balanceInBs;
      } else {
        throw new Error(data.message || "Error obteniendo saldo");
      }
    } catch (error) {
      console.error("‚ùå Error obteniendo saldo:", error.message);
      // Lanzar el error para que se muestre el mensaje de error
      throw error;
    }
  }

  // Formatear moneda venezolana
  formatCurrency(amount) {
    return new Intl.NumberFormat("es-VE", {
      minimumFractionDigits: 2,
      maximumFractionDigits: 2,
    }).format(amount);
  }

  // Calcular centavos autom√°ticamente
  calculateCents(amount) {
    const cents = Math.round(parseFloat(amount || 0) * 100);
    document.getElementById("amount-cents").value = cents;
  }

  // Manejar solicitud de dep√≥sito
  async handleDepositRequest() {
    const amount = parseFloat(document.getElementById("amount").value);
    const amountCents = parseInt(document.getElementById("amount-cents").value);

    if (!amount || amount <= 0) {
      this.showError("Monto inv√°lido", "Por favor ingresa un monto v√°lido");
      return;
    }

    try {
      this.showLoading("Creando solicitud de dep√≥sito...");

      // Crear solicitud de dep√≥sito
      const transaction = await this.createDepositRequest(amountCents);

      this.currentTransaction = transaction;

      // Mostrar mensaje de confirmaci√≥n exitosa
      this.showSuccessScreen(transaction);
    } catch (error) {
      console.error("Error creando solicitud:", error);
      this.showError("Error en la solicitud", error.message);
    }
  }

  // Crear solicitud de dep√≥sito
  async createDepositRequest(amountCents) {
    try {
      console.log("üöÄ Iniciando creaci√≥n de solicitud de dep√≥sito...");
      console.log("üí∞ Monto en centavos:", amountCents);
      console.log("üë§ Usuario:", this.userData);

      // Obtener token de autenticaci√≥n
      console.log("üîê Obteniendo token de autenticaci√≥n...");
      const token = await this.getBotToken();

      if (!token || token === "bot_token_placeholder") {
        throw new Error(
          "No se pudo obtener un token v√°lido para la autenticaci√≥n"
        );
      }

      console.log("‚úÖ Token obtenido:", token.substring(0, 20) + "...");

      // Obtener el jugador existente
      console.log("üë• Obteniendo jugador existente...");
      const jugador = await this.getJugador(token);

      if (!jugador) {
        throw new Error(
          "No se pudo obtener el jugador. Verifica que el usuario est√© registrado."
        );
      }

      if (!jugador._id) {
        throw new Error("El jugador no tiene un ID v√°lido");
      }

      console.log("‚úÖ Jugador obtenido:", {
        id: jugador._id,
        username: jugador.username,
        saldo: jugador.saldo,
      });

      // Crear la transacci√≥n de dep√≥sito
      const payload = {
        jugadorId: jugador._id,
        telegramId: this.userData.id.toString(),
        tipo: "credito",
        categoria: "deposito",
        monto: amountCents,
        descripcion: `Dep√≥sito de ${(amountCents / 100).toLocaleString(
          "es-VE"
        )} Bs`,
        saldoAnterior: jugador.saldo || 0,
        referencia: `DEP_${this.userData.id}_${Date.now()}`,
        estado: "pendiente",
        infoPago: {
          metodoPago: "pago_movil",
        },
        creadoPor: jugador._id,
      };

      console.log("üìù Creando transacci√≥n de dep√≥sito:", payload);

      const response = await fetch(
        `${this.backendUrl}/transacciones/solicitud`,
        {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${token}`,
          },
          body: JSON.stringify(payload),
        }
      );

      console.log(
        "üì° Respuesta del servidor:",
        response.status,
        response.statusText
      );

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        console.error("‚ùå Error del servidor:", errorData);
        throw new Error(
          errorData.mensaje ||
            `Error del servidor: ${response.status} - ${response.statusText}`
        );
      }

      const transactionData = await response.json();
      console.log("‚úÖ Transacci√≥n creada exitosamente:", transactionData);

      return transactionData.transaccion || transactionData;
    } catch (error) {
      console.error("‚ùå Error creando transacci√≥n:", error);
      // Agregar informaci√≥n adicional al error para debugging
      const errorMessage =
        error.message +
        `\n\nDetalles t√©cnicos:\n- Usuario ID: ${
          this.userData?.id
        }\n- Backend URL: ${
          this.backendUrl
        }\n- Timestamp: ${new Date().toISOString()}`;
      throw new Error(errorMessage);
    }
  }

  // Obtener jugador existente
  async getJugador(token) {
    try {
      console.log("üîç Obteniendo jugador existente...");
      console.log("üë§ Telegram ID:", this.userData.id);

      // Obtener el jugador existente usando el endpoint correcto
      const response = await fetch(
        `${this.backendUrl}/jugadores/${this.userData.id}`,
        {
          method: "GET",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${token}`,
          },
        }
      );

      console.log(
        "üì° Respuesta del servidor:",
        response.status,
        response.statusText
      );

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        console.error("‚ùå Error obteniendo jugador:", errorData);

        if (response.status === 404) {
          throw new Error(
            "Jugador no encontrado. Verifica que el usuario est√© registrado en el sistema."
          );
        } else if (response.status === 401 || response.status === 403) {
          throw new Error("Error de autenticaci√≥n. Token inv√°lido o expirado.");
        } else {
          throw new Error(
            errorData.mensaje ||
              `Error del servidor: ${response.status} - ${response.statusText}`
          );
        }
      }

      const jugadorData = await response.json();
      console.log("‚úÖ Jugador obtenido:", jugadorData);

      // El endpoint devuelve directamente el objeto jugador, no envuelto
      if (jugadorData && jugadorData._id) {
        return jugadorData;
      } else {
        throw new Error(
          "La respuesta del servidor no contiene un jugador v√°lido"
        );
      }
    } catch (error) {
      console.error("‚ùå Error obteniendo jugador:", error);
      throw error;
    }
  }

  // Obtener token del bot
  async getBotToken() {
    // Credenciales del bot (en producci√≥n estas vendr√≠an del build)
    const BOT_EMAIL = "bot@elpatio.games";
    const BOT_PASSWORD = "BotCl4ve#Sup3rS3gur4!2025";

    try {
      console.log("üîê Obteniendo token del bot...");

      const response = await fetch(`${this.backendUrl}/admin/login`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          email: BOT_EMAIL,
          password: BOT_PASSWORD,
        }),
      });

      if (response.ok) {
        const data = await response.json();
        console.log("‚úÖ Token del bot obtenido exitosamente");
        return data.token;
      } else {
        console.error(
          "‚ùå Error en login del bot:",
          response.status,
          response.statusText
        );

        // Fallback: usar token de cajero si el bot no est√° disponible
        console.log("üîÑ Intentando fallback con cajero...");
        const fallbackResponse = await fetch(
          `${this.backendUrl}/cajeros/login`,
          {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              email: "luis@ejemplo.com",
              password: "clave123",
            }),
          }
        );

        if (fallbackResponse.ok) {
          const fallbackData = await fallbackResponse.json();
          console.log("‚úÖ Token de cajero obtenido como fallback");
          return fallbackData.token;
        }
      }
    } catch (error) {
      console.error("‚ùå Error obteniendo token:", error);
    }

    // Si todo falla, usar token placeholder
    console.warn("‚ö†Ô∏è Usando token placeholder");
    return "bot_token_placeholder";
  }

  // Formatear referencia para mostrar solo √∫ltimos 6 d√≠gitos
  formatReference(referencia) {
    if (!referencia) return "N/A";
    if (referencia.length <= 6) return referencia;
    return "..." + referencia.slice(-6);
  }

  // M√©todo para verificar estado de transacci√≥n (usando X-Telegram-ID)
  async verificarEstadoTransaccion(transaccionId) {
    try {
      const telegramId = this.userData.id.toString();

      // LOG TEMPORAL: Mostrar en pantalla
      this.mostrarLogTemporal(
        `üîç Verificando estado de transacci√≥n: ${transaccionId}`
      );
      this.mostrarLogTemporal(`üë§ Telegram ID: ${telegramId}`);
      this.mostrarLogTemporal(
        `üîó URL: ${this.backendUrl}/transacciones/${transaccionId}/estado`
      );

      const response = await fetch(
        `${this.backendUrl}/transacciones/${transaccionId}/estado`,
        {
          method: "GET",
          headers: {
            "Content-Type": "application/json",
            "X-Telegram-ID": telegramId,
          },
        }
      );

      this.mostrarLogTemporal(
        `üì° Respuesta HTTP: ${response.status} ${response.statusText}`
      );

      if (response.ok) {
        const data = await response.json();
        this.mostrarLogTemporal(
          `‚úÖ Datos recibidos: ${JSON.stringify(data, null, 2)}`
        );
        return data;
      } else {
        const errorText = await response.text();
        this.mostrarLogTemporal(`‚ùå Error HTTP: ${errorText}`);
        return null;
      }
    } catch (error) {
      this.mostrarLogTemporal(`üí• Error de conexi√≥n: ${error.message}`);
      console.error("Error verificando estado:", error);
      return null;
    }
  }

  // Iniciar polling cuando se crea la transacci√≥n
  iniciarPollingEstado(transaccionId) {
    this.mostrarLogTemporal(
      `üîÑ Iniciando polling para transacci√≥n: ${transaccionId}`
    );

    const intervalId = setInterval(async () => {
      this.mostrarLogTemporal(
        `‚è∞ Verificando estado... (${new Date().toLocaleTimeString()})`
      );
      const estado = await this.verificarEstadoTransaccion(transaccionId);

      if (estado) {
        this.mostrarLogTemporal(`üìä Estado actual: ${estado.estado}`);
        this.mostrarLogTemporal(`üë§ Cajero asignado: ${estado.cajeroAsignado}`);

        if (estado.estado === "en_proceso" && estado.cajeroAsignado) {
          // ¬°Cajero asignado! Mostrar datos bancarios
          this.mostrarLogTemporal(
            `‚úÖ Cajero asignado, mostrando datos bancarios`
          );
          this.mostrarDatosCajero(estado);
          clearInterval(intervalId);
        } else if (
          estado.estado === "rechazada" ||
          estado.estado === "cancelada"
        ) {
          // Transacci√≥n cancelada
          this.mostrarLogTemporal(`‚ùå Transacci√≥n cancelada o rechazada`);
          this.mostrarTransaccionCancelada(estado);
          clearInterval(intervalId);
        } else if (estado.estado === "completada") {
          // Transacci√≥n completada
          this.mostrarLogTemporal(`üéâ Transacci√≥n completada`);
          this.mostrarTransaccionCompletada(estado);
          clearInterval(intervalId);
        } else {
          this.mostrarLogTemporal(
            `‚è≥ Esperando cajero... Estado: ${estado.estado}`
          );
        }
      } else {
        this.mostrarLogTemporal(`‚ùå No se pudo obtener el estado`);
      }
    }, 3000); // Verificar cada 3 segundos

    // Limpiar polling despu√©s de 5 minutos
    setTimeout(() => {
      this.mostrarLogTemporal(`‚è∞ Polling expirado despu√©s de 5 minutos`);
      clearInterval(intervalId);
    }, 300000);
  }

  // Mostrar pantalla de √©xito
  showSuccessScreen(transaction) {
    document.getElementById("waiting-amount").textContent = `${
      transaction.monto / 100
    } Bs`;
    document.getElementById("waiting-reference").textContent =
      this.formatReference(transaction.referencia || transaction._id);
    document.getElementById("waiting-status").textContent =
      "Creada exitosamente";

    // Ocultar el spinner de "Buscando cajero"
    const loadingContainer = document.querySelector(
      "#waiting-screen .loading-container"
    );
    if (loadingContainer) {
      loadingContainer.style.display = "none";
    }

    // Actualizar el t√≠tulo de la pantalla
    const headerTitle = document.querySelector("#waiting-screen .header h1");
    if (headerTitle) {
      headerTitle.textContent = "‚úÖ Solicitud Creada";
    }

    // Actualizar el subt√≠tulo con mensaje simple
    const subtitle = document.querySelector(
      "#waiting-screen .header .subtitle"
    );
    if (subtitle) {
      subtitle.textContent = "Tu solicitud de dep√≥sito se cre√≥ exitosamente";
    }

    // Actualizar los detalles de la transacci√≥n
    const amountElement = document.getElementById("waiting-amount");
    if (amountElement) {
      amountElement.textContent = `${(transaction.monto / 100).toLocaleString(
        "es-VE"
      )} Bs`;
    }

    const referenceElement = document.getElementById("waiting-reference");
    if (referenceElement) {
      referenceElement.textContent = this.formatReference(
        transaction.referencia || transaction._id
      );
    }

    const statusElement = document.getElementById("waiting-status");
    if (statusElement) {
      statusElement.textContent = "Pago M√≥vil";
      statusElement.className = "status-pending";
    }

    // Agregar mensaje de asignaci√≥n de cajero
    const transactionInfo = document.querySelector(
      "#waiting-screen .transaction-info"
    );
    if (transactionInfo) {
      const cajeroMessage = document.createElement("div");
      cajeroMessage.className = "cajero-message";
      cajeroMessage.innerHTML = `
        <div class="info-card">
          <p>üîÑ Se est√° asignando un cajero para completar tu solicitud</p>
        </div>
      `;
      transactionInfo.appendChild(cajeroMessage);
    }

    // Iniciar polling para verificar cuando se asigne un cajero
    this.iniciarPollingEstado(transaction._id);

    this.showScreen("waiting-screen");
  }

  // Mostrar datos del cajero asignado
  mostrarDatosCajero(estado) {
    const cajero = estado.cajero;

    this.mostrarLogTemporal(
      `üè¶ Mostrando datos del cajero: ${JSON.stringify(cajero, null, 2)}`
    );
    this.mostrarLogTemporal(
      `üìä Estado completo: ${JSON.stringify(estado, null, 2)}`
    );

    // Actualizar la pantalla con los datos del cajero
    const bankInfoScreen = document.getElementById("bank-info-screen");
    this.mostrarLogTemporal(
      `üîç Buscando pantalla bank-info-screen: ${
        bankInfoScreen ? "ENCONTRADA" : "NO ENCONTRADA"
      }`
    );

    if (bankInfoScreen) {
      // Actualizar elementos de la pantalla de datos bancarios
      const cajeroBanco = document.getElementById("bank-name"); // Banco del cajero
      const cajeroTelefono = document.getElementById("bank-phone"); // Tel√©fono del cajero
      const cajeroCedula = document.getElementById("bank-id"); // C√©dula del cajero
      const montoPago = document.getElementById("bank-amount"); // Monto a pagar

      this.mostrarLogTemporal(`üîç Elementos encontrados:`);
      this.mostrarLogTemporal(
        `  - bank-name (banco): ${cajeroBanco ? "S√ç" : "NO"}`
      );
      this.mostrarLogTemporal(
        `  - bank-phone (tel√©fono): ${cajeroTelefono ? "S√ç" : "NO"}`
      );
      this.mostrarLogTemporal(
        `  - bank-id (c√©dula): ${cajeroCedula ? "S√ç" : "NO"}`
      );
      this.mostrarLogTemporal(
        `  - bank-amount (monto): ${montoPago ? "S√ç" : "NO"}`
      );

      if (cajeroBanco) {
        cajeroBanco.textContent = cajero.datosPago.banco;
        this.mostrarLogTemporal(
          `‚úÖ Banco actualizado: ${cajero.datosPago.banco}`
        );
      }
      if (cajeroTelefono) {
        cajeroTelefono.textContent = cajero.telefono;
        this.mostrarLogTemporal(`‚úÖ Tel√©fono actualizado: ${cajero.telefono}`);
      }
      if (cajeroCedula) {
        cajeroCedula.textContent = `${cajero.datosPago.cedula.prefijo}-${cajero.datosPago.cedula.numero}`;
        this.mostrarLogTemporal(
          `‚úÖ C√©dula actualizada: ${cajero.datosPago.cedula.prefijo}-${cajero.datosPago.cedula.numero}`
        );
      }
      if (montoPago) {
        montoPago.textContent = `${(estado.monto / 100).toLocaleString(
          "es-VE"
        )} Bs`;
        this.mostrarLogTemporal(
          `‚úÖ Monto actualizado: ${(estado.monto / 100).toLocaleString(
            "es-VE"
          )} Bs`
        );
      }

      this.mostrarLogTemporal(`üîÑ Cambiando a pantalla bank-info-screen`);
      this.showScreen("bank-info-screen");
    } else {
      this.mostrarLogTemporal(
        `‚ö†Ô∏è No se encontr√≥ la pantalla bank-info-screen, usando fallback`
      );
      // Fallback: mostrar en la pantalla de espera
      this.actualizarPantallaEsperaConCajero(estado);
    }
  }

  // Actualizar pantalla de espera con datos del cajero (fallback)
  actualizarPantallaEsperaConCajero(estado) {
    const cajero = estado.cajero;

    // Actualizar el t√≠tulo de la pantalla
    const headerTitle = document.querySelector("#waiting-screen .header h1");
    if (headerTitle) {
      headerTitle.textContent = "‚úÖ Cajero Asignado";
    }

    // Actualizar el subt√≠tulo
    const subtitle = document.querySelector(
      "#waiting-screen .header .subtitle"
    );
    if (subtitle) {
      subtitle.textContent = "Realiza el pago m√≥vil con los datos del cajero";
    }

    // Actualizar el estado
    const statusElement = document.getElementById("waiting-status");
    if (statusElement) {
      statusElement.textContent = "Cajero Asignado";
      statusElement.className = "status-assigned";
    }

    // Agregar informaci√≥n del cajero
    const transactionInfo = document.querySelector(
      "#waiting-screen .transaction-info"
    );
    if (transactionInfo) {
      // Limpiar mensaje anterior
      const cajeroMessage = transactionInfo.querySelector(".cajero-message");
      if (cajeroMessage) {
        cajeroMessage.remove();
      }

      // Agregar nueva informaci√≥n del cajero
      const nuevaInfoCajero = document.createElement("div");
      nuevaInfoCajero.className = "cajero-message";
      nuevaInfoCajero.innerHTML = `
        <div class="info-card cajero-info">
          <h3>üè¶ Datos del Cajero</h3>
          <p><strong>Nombre:</strong> ${cajero.nombre}</p>
          <p><strong>Tel√©fono:</strong> ${cajero.telefono}</p>
          <p><strong>Banco:</strong> ${cajero.datosPago.banco}</p>
          <p><strong>C√©dula:</strong> ${cajero.datosPago.cedula.prefijo}-${
        cajero.datosPago.cedula.numero
      }</p>
          <p><strong>Monto:</strong> ${(estado.monto / 100).toLocaleString(
            "es-VE"
          )} Bs</p>
          <p><strong>Referencia:</strong> ${estado.referencia}</p>
        </div>
      `;
      transactionInfo.appendChild(nuevaInfoCajero);
    }
  }

  // Mostrar transacci√≥n cancelada
  mostrarTransaccionCancelada(estado) {
    console.log("‚ùå Mostrando transacci√≥n cancelada:", estado);

    // Actualizar el t√≠tulo
    const headerTitle = document.querySelector("#waiting-screen .header h1");
    if (headerTitle) {
      headerTitle.textContent = "‚ùå Transacci√≥n Cancelada";
    }

    // Actualizar el subt√≠tulo
    const subtitle = document.querySelector(
      "#waiting-screen .header .subtitle"
    );
    if (subtitle) {
      subtitle.textContent = "Tu transacci√≥n ha sido cancelada o rechazada";
    }

    // Actualizar el estado
    const statusElement = document.getElementById("waiting-status");
    if (statusElement) {
      statusElement.textContent =
        estado.estado === "rechazada" ? "Rechazada" : "Cancelada";
      statusElement.className = "status-cancelled";
    }
  }

  // Mostrar transacci√≥n completada
  mostrarTransaccionCompletada(estado) {
    console.log("üéâ Mostrando transacci√≥n completada:", estado);

    // Actualizar el t√≠tulo
    const headerTitle = document.querySelector("#waiting-screen .header h1");
    if (headerTitle) {
      headerTitle.textContent = "üéâ ¬°Transacci√≥n Completada!";
    }

    // Actualizar el subt√≠tulo
    const subtitle = document.querySelector(
      "#waiting-screen .header .subtitle"
    );
    if (subtitle) {
      subtitle.textContent = "Tu dep√≥sito ha sido procesado exitosamente";
    }

    // Actualizar el estado
    const statusElement = document.getElementById("waiting-status");
    if (statusElement) {
      statusElement.textContent = "Completada";
      statusElement.className = "status-completed";
    }
  }

  // Mostrar transacci√≥n rechazada
  mostrarTransaccionRechazada(estado) {
    this.mostrarLogTemporal(
      `‚ùå Mostrando transacci√≥n rechazada: ${JSON.stringify(estado, null, 2)}`
    );

    // Actualizar el t√≠tulo
    const headerTitle = document.querySelector("#waiting-screen .header h1");
    if (headerTitle) {
      headerTitle.textContent = "‚ùå Transacci√≥n Rechazada";
    }

    // Actualizar el subt√≠tulo
    const subtitle = document.querySelector(
      "#waiting-screen .header .subtitle"
    );
    if (subtitle) {
      subtitle.textContent = "El cajero rechaz√≥ tu transacci√≥n";
    }

    // Actualizar el estado
    const statusElement = document.getElementById("waiting-status");
    if (statusElement) {
      statusElement.textContent = "Rechazada";
      statusElement.className = "status-rejected";
    }

    // Mostrar pantalla de espera con estado rechazado
    this.showScreen("waiting-screen");
  }

  // Manejar confirmaci√≥n de pago
  async handlePaymentConfirmation() {
    const formData = new FormData(
      document.getElementById("payment-confirmation-form")
    );

    const paymentData = {
      banco: formData.get("payment-bank"),
      telefono: formData.get("payment-phone"),
      referencia: formData.get("payment-reference"),
      fecha: formData.get("payment-date"),
    };

    try {
      this.showLoading("Confirmando pago...");

      // Confirmar pago del usuario
      await this.confirmUserPayment(this.currentTransaction._id, paymentData);

      // Mostrar pantalla de confirmaci√≥n final
      this.showConfirmationScreen();
    } catch (error) {
      console.error("Error confirmando pago:", error);
      this.showError("Error confirmando pago", error.message);
    }
  }

  // Confirmar pago del usuario
  async confirmUserPayment(transactionId, paymentData) {
    try {
      this.mostrarLogTemporal(
        `üí≥ Confirmando pago para transacci√≥n: ${transactionId}`
      );
      this.mostrarLogTemporal(
        `üìä Datos del pago: ${JSON.stringify(paymentData, null, 2)}`
      );

      // Preparar datos para el endpoint
      const payload = {
        bancoOrigen: paymentData.banco,
        telefonoOrigen: paymentData.telefono,
        numeroReferencia: paymentData.referencia,
        fechaPago: paymentData.fecha,
        metodoPago: "pago_movil",
      };

      this.mostrarLogTemporal(
        `üì§ Enviando datos al backend: ${JSON.stringify(payload, null, 2)}`
      );

      // Obtener token del bot para autenticaci√≥n
      const token = await this.getBotToken();
      if (!token || token === "bot_token_placeholder") {
        throw new Error("No se pudo obtener token de autenticaci√≥n");
      }

      // Hacer llamada al endpoint de confirmaci√≥n de pago
      const response = await fetch(
        `${this.backendUrl}/transacciones/${transactionId}/confirmar-pago-usuario`,
        {
          method: "PUT",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${token}`,
          },
          body: JSON.stringify(payload),
        }
      );

      this.mostrarLogTemporal(
        `üì° Respuesta HTTP: ${response.status} ${response.statusText}`
      );

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(
          errorData.mensaje ||
            `Error del servidor: ${response.status} - ${response.statusText}`
        );
      }

      const result = await response.json();
      this.mostrarLogTemporal(
        `‚úÖ Pago confirmado exitosamente: ${JSON.stringify(result, null, 2)}`
      );

      // Actualizar estado de la transacci√≥n
      this.currentTransaction.estado = "en_proceso";
      this.currentTransaction.infoPago = payload;

      // Iniciar polling para esperar confirmaci√≥n del cajero
      this.iniciarPollingConfirmacionCajero(transactionId);

      return result;
    } catch (error) {
      this.mostrarLogTemporal(`‚ùå Error confirmando pago: ${error.message}`);
      throw error;
    }
  }

  // Iniciar polling para esperar confirmaci√≥n del cajero
  iniciarPollingConfirmacionCajero(transaccionId) {
    this.mostrarLogTemporal(
      `üîÑ Iniciando polling para confirmaci√≥n del cajero: ${transaccionId}`
    );

    // Mostrar pantalla de confirmaci√≥n mientras esperamos
    this.showConfirmationScreen();

    const intervalId = setInterval(async () => {
      this.mostrarLogTemporal(
        `‚è∞ Verificando confirmaci√≥n del cajero... (${new Date().toLocaleTimeString()})`
      );
      const estado = await this.verificarEstadoTransaccion(transaccionId);

      if (estado) {
        this.mostrarLogTemporal(`üìä Estado actual: ${estado.estado}`);

        if (estado.estado === "completada") {
          this.mostrarLogTemporal(`üéâ Transacci√≥n completada por el cajero`);
          this.mostrarTransaccionCompletada(estado);
          clearInterval(intervalId);
        } else if (estado.estado === "rechazada") {
          this.mostrarLogTemporal(`‚ùå Transacci√≥n rechazada por el cajero`);
          this.mostrarTransaccionRechazada(estado);
          clearInterval(intervalId);
        } else if (estado.estado === "confirmada") {
          this.mostrarLogTemporal(
            `‚úÖ Transacci√≥n confirmada, esperando procesamiento`
          );
          // Continuar polling hasta que se complete
        } else {
          this.mostrarLogTemporal(
            `‚è≥ Esperando confirmaci√≥n del cajero... Estado: ${estado.estado}`
          );
        }
      } else {
        this.mostrarLogTemporal(`‚ùå No se pudo obtener el estado`);
      }
    }, 5000); // Verificar cada 5 segundos

    // Timeout de 30 minutos (1800000 ms)
    const timeoutId = setTimeout(() => {
      this.mostrarLogTemporal(
        `‚è∞ Timeout de 30 minutos alcanzado, cancelando transacci√≥n`
      );
      clearInterval(intervalId);
      this.cancelarTransaccionPorTimeout(transaccionId);
    }, 1800000); // 30 minutos

    // Guardar IDs para poder limpiarlos si es necesario
    this.pollingIntervalId = intervalId;
    this.timeoutId = timeoutId;
  }

  // Cancelar transacci√≥n por timeout
  async cancelarTransaccionPorTimeout(transaccionId) {
    try {
      this.mostrarLogTemporal(
        `üö´ Cancelando transacci√≥n por timeout: ${transaccionId}`
      );

      // Obtener token del bot para autenticaci√≥n
      const token = await this.getBotToken();
      if (!token || token === "bot_token_placeholder") {
        throw new Error("No se pudo obtener token de autenticaci√≥n");
      }

      // Hacer llamada al endpoint de rechazo
      const response = await fetch(
        `${this.backendUrl}/transacciones/${transaccionId}/rechazar`,
        {
          method: "PUT",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${token}`,
          },
          body: JSON.stringify({
            motivo: "Timeout: Usuario no complet√≥ el pago en 30 minutos",
          }),
        }
      );

      this.mostrarLogTemporal(
        `üì° Respuesta de cancelaci√≥n: ${response.status} ${response.statusText}`
      );

      if (response.ok) {
        this.mostrarLogTemporal(`‚úÖ Transacci√≥n cancelada exitosamente`);
        this.mostrarTransaccionCancelada({
          estado: "cancelada",
          motivo: "Timeout de 30 minutos",
        });
      } else {
        this.mostrarLogTemporal(`‚ùå Error cancelando transacci√≥n`);
        this.showError(
          "Error",
          "No se pudo cancelar la transacci√≥n autom√°ticamente"
        );
      }
    } catch (error) {
      this.mostrarLogTemporal(
        `‚ùå Error en cancelaci√≥n por timeout: ${error.message}`
      );
      this.showError("Error", "Error cancelando la transacci√≥n por timeout");
    }
  }

  // Mostrar pantalla de confirmaci√≥n final
  showConfirmationScreen() {
    document.getElementById("final-amount").textContent = `${
      this.currentTransaction.monto / 100
    } Bs`;
    document.getElementById("final-reference").textContent =
      this.currentTransaction.referencia;
    document.getElementById("final-status").textContent = "En verificaci√≥n";

    this.showScreen("confirmation-screen");
  }

  // Mostrar loading
  showLoading(message = "Cargando...") {
    const loadingScreen = document.getElementById("loading");
    const loadingText = loadingScreen.querySelector("p");
    loadingText.textContent = message;
    this.showScreen("loading");
  }

  // Mostrar error
  showError(title, message) {
    document.getElementById("error-title").textContent = title;
    document.getElementById("error-message").textContent = message;
    this.showScreen("error-screen");
  }

  // Enviar datos al bot (para comunicaci√≥n con el backend)
  sendDataToBot(data) {
    this.tg.sendData(JSON.stringify(data));
  }

  // Funci√≥n para copiar texto al portapapeles
  async copyToClipboard(elementId) {
    try {
      const element = document.getElementById(elementId);
      if (!element) {
        this.mostrarLogTemporal(`‚ùå Elemento ${elementId} no encontrado`);
        return;
      }

      const textToCopy = element.textContent.trim();
      if (!textToCopy || textToCopy === "-") {
        this.mostrarLogTemporal(`‚ùå No hay texto para copiar en ${elementId}`);
        return;
      }

      // Usar la API del portapapeles moderna
      if (navigator.clipboard && window.isSecureContext) {
        await navigator.clipboard.writeText(textToCopy);
        this.mostrarLogTemporal(`‚úÖ Copiado al portapapeles: ${textToCopy}`);
        this.showCopyFeedback(elementId, "‚úÖ");
      } else {
        // Fallback para navegadores m√°s antiguos o contextos no seguros
        const textArea = document.createElement("textarea");
        textArea.value = textToCopy;
        textArea.style.position = "fixed";
        textArea.style.left = "-999999px";
        textArea.style.top = "-999999px";
        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();

        try {
          document.execCommand("copy");
          this.mostrarLogTemporal(`‚úÖ Copiado (fallback): ${textToCopy}`);
          this.showCopyFeedback(elementId, "‚úÖ");
        } catch (err) {
          this.mostrarLogTemporal(`‚ùå Error copiando: ${err.message}`);
          this.showCopyFeedback(elementId, "‚ùå");
        }

        document.body.removeChild(textArea);
      }
    } catch (error) {
      this.mostrarLogTemporal(`‚ùå Error en copyToClipboard: ${error.message}`);
      this.showCopyFeedback(elementId, "‚ùå");
    }
  }

  // Funci√≥n para copiar todos los datos bancarios
  async copyAllBankData() {
    try {
      const bankName =
        document.getElementById("bank-name")?.textContent?.trim() || "";
      const bankPhone =
        document.getElementById("bank-phone")?.textContent?.trim() || "";
      const bankId =
        document.getElementById("bank-id")?.textContent?.trim() || "";
      const bankAmount =
        document.getElementById("bank-amount")?.textContent?.trim() || "";

      if (!bankName || bankName === "-") {
        this.mostrarLogTemporal(`‚ùå No hay datos bancarios para copiar`);
        return;
      }

      const allData = `Banco: ${bankName}\nTel√©fono: ${bankPhone}\nC√©dula: ${bankId}\nMonto: ${bankAmount}`;

      // Usar la API del portapapeles moderna
      if (navigator.clipboard && window.isSecureContext) {
        await navigator.clipboard.writeText(allData);
        this.mostrarLogTemporal(`‚úÖ Todos los datos copiados al portapapeles`);
        this.showCopyAllFeedback("‚úÖ");
      } else {
        // Fallback para navegadores m√°s antiguos
        const textArea = document.createElement("textarea");
        textArea.value = allData;
        textArea.style.position = "fixed";
        textArea.style.left = "-999999px";
        textArea.style.top = "-999999px";
        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();

        try {
          document.execCommand("copy");
          this.mostrarLogTemporal(`‚úÖ Todos los datos copiados (fallback)`);
          this.showCopyAllFeedback("‚úÖ");
        } catch (err) {
          this.mostrarLogTemporal(
            `‚ùå Error copiando todos los datos: ${err.message}`
          );
          this.showCopyAllFeedback("‚ùå");
        }

        document.body.removeChild(textArea);
      }
    } catch (error) {
      this.mostrarLogTemporal(`‚ùå Error en copyAllBankData: ${error.message}`);
      this.showCopyAllFeedback("‚ùå");
    }
  }

  // Mostrar feedback visual para copiado individual
  showCopyFeedback(elementId, status) {
    const element = document.getElementById(elementId);
    if (!element) return;

    const originalText = element.textContent;
    const originalClass = element.className;

    // Cambiar temporalmente el texto y estilo
    element.textContent = status === "‚úÖ" ? "¬°Copiado!" : "Error";
    element.className =
      originalClass + (status === "‚úÖ" ? " copy-success" : " copy-error");

    // Restaurar despu√©s de 2 segundos
    setTimeout(() => {
      element.textContent = originalText;
      element.className = originalClass;
    }, 2000);
  }

  // Mostrar feedback visual para copiado de todos los datos
  showCopyAllFeedback(status) {
    const button = document.getElementById("copy-all-btn");
    if (!button) return;

    const originalText = button.textContent;
    const originalClass = button.className;

    // Cambiar temporalmente el texto y estilo
    button.textContent =
      status === "‚úÖ" ? "¬°Todos copiados!" : "Error al copiar";
    button.className =
      originalClass + (status === "‚úÖ" ? " copy-success" : " copy-error");

    // Restaurar despu√©s de 3 segundos
    setTimeout(() => {
      button.textContent = originalText;
      button.className = originalClass;
    }, 3000);
  }

  // Funci√≥n temporal para mostrar logs en pantalla (para debugging)
  mostrarLogTemporal(mensaje) {
    console.log(mensaje); // Siempre en consola

    // Solo mostrar logs visuales si est√°n habilitados
    if (!this.logsVisibles) {
      return;
    }

    // Crear o obtener el contenedor de logs
    let logContainer = document.getElementById("debug-logs");
    if (!logContainer) {
      logContainer = document.createElement("div");
      logContainer.id = "debug-logs";
      logContainer.style.cssText = `
        position: fixed;
        top: 10px;
        right: 10px;
        width: 300px;
        max-height: 400px;
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 10px;
        border-radius: 8px;
        font-family: monospace;
        font-size: 11px;
        z-index: 10000;
        overflow-y: auto;
        border: 2px solid #ff6b6b;
        display: none;
      `;
      document.body.appendChild(logContainer);
    }

    // Agregar el mensaje con timestamp
    const timestamp = new Date().toLocaleTimeString();
    const logEntry = document.createElement("div");
    logEntry.style.cssText = `
      margin-bottom: 5px;
      padding: 2px;
      border-bottom: 1px solid #333;
      word-wrap: break-word;
    `;
    logEntry.textContent = `[${timestamp}] ${mensaje}`;

    logContainer.appendChild(logEntry);

    // Mantener solo los √∫ltimos 20 logs
    while (logContainer.children.length > 20) {
      logContainer.removeChild(logContainer.firstChild);
    }

    // Auto-scroll al final
    logContainer.scrollTop = logContainer.scrollHeight;
  }

  // Toggle para mostrar/ocultar logs visuales
  toggleLogs() {
    this.logsVisibles = !this.logsVisibles;
    const logContainer = document.getElementById("debug-logs");
    const toggleButton = document.getElementById("logs-toggle-btn");

    if (logContainer) {
      logContainer.style.display = this.logsVisibles ? "block" : "none";
    }

    if (toggleButton) {
      toggleButton.textContent = this.logsVisibles ? "üîç" : "üìã";
      toggleButton.title = this.logsVisibles ? "Ocultar logs" : "Mostrar logs";
    }

    console.log(
      `Logs visuales ${this.logsVisibles ? "habilitados" : "deshabilitados"}`
    );
  }

  // Crear bot√≥n toggle de logs
  crearBotonToggleLogs() {
    const toggleButton = document.createElement("button");
    toggleButton.id = "logs-toggle-btn";
    toggleButton.style.cssText = `
      position: fixed;
      bottom: 20px;
      left: 20px;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: var(--tg-theme-button-color, #2481cc);
      color: white;
      border: none;
      font-size: 20px;
      cursor: pointer;
      z-index: 10001;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    `;

    toggleButton.textContent = "üìã";
    toggleButton.title = "Mostrar logs";

    // Efectos hover
    toggleButton.addEventListener("mouseenter", () => {
      toggleButton.style.transform = "scale(1.1)";
      toggleButton.style.boxShadow = "0 6px 16px rgba(0, 0, 0, 0.4)";
    });

    toggleButton.addEventListener("mouseleave", () => {
      toggleButton.style.transform = "scale(1)";
      toggleButton.style.boxShadow = "0 4px 12px rgba(0, 0, 0, 0.3)";
    });

    // Click handler
    toggleButton.addEventListener("click", () => {
      this.toggleLogs();
    });

    document.body.appendChild(toggleButton);
  }

  // M√©todo para comunicaci√≥n con el bot
  async communicateWithBot(action, data) {
    try {
      // Enviar datos al bot
      this.sendDataToBot({
        action,
        data,
        userId: this.userData.id,
        timestamp: new Date().toISOString(),
      });

      // Tambi√©n hacer llamada HTTP directa al backend del bot
      const response = await fetch(`${this.backendUrl}/webapp/deposito`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          action,
          data,
          userId: this.userData.id,
          timestamp: new Date().toISOString(),
        }),
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      return await response.json();
    } catch (error) {
      console.error("Error comunic√°ndose con el bot:", error);
      throw error;
    }
  }
}

// Hacer las funciones de copiado globales para que funcionen desde el HTML
window.copyToClipboard = function (elementId) {
  if (window.depositApp) {
    window.depositApp.copyToClipboard(elementId);
  }
};

window.copyAllBankData = function () {
  if (window.depositApp) {
    window.depositApp.copyAllBankData();
  }
};

// Inicializar la app cuando se carga la p√°gina
document.addEventListener("DOMContentLoaded", () => {
  window.depositApp = new DepositApp();
});

// Manejar eventos de Telegram Web App
window.Telegram.WebApp.onEvent("mainButtonClicked", () => {
  console.log("Main button clicked");
  // L√≥gica adicional si es necesario
});

window.Telegram.WebApp.onEvent("backButtonClicked", () => {
  console.log("Back button clicked");
  // L√≥gica de navegaci√≥n hacia atr√°s
});

// Exportar para uso global
window.DepositApp = DepositApp;
